---
import { storyblokEditable } from '@storyblok/astro';
import StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro';
import { getStoryblokStories } from '~/lib/storyblok';
import ResultsSummary from '~/components/ResultsSummary.astro';
import { buildStoryblokQuery, processStories } from '~/utils/storyblok';
import { parseGridConfig } from '~/utils/grid';

const { blok } = Astro.props;
const { numberOfColumns, blocks, gridClasses, sectionClasses, fetchItems, showResultsSummary } = blok;

// Extract URL parameters
const tagFilter = Astro.url.searchParams.get('tag');
const searchQuery = Astro.url.searchParams.get('search');

// Fetch and process items if fetchItems is specified
let fetchedItems = [];
if (fetchItems) {
  try {
    const queryParams = buildStoryblokQuery(fetchItems, searchQuery);
    const stories = await getStoryblokStories(queryParams);
    fetchedItems = processStories(stories, tagFilter, fetchItems);
  } catch (error) {
    console.error(`Error fetching ${fetchItems}:`, error);
  }
}

// Combine all blocks
const allBlocks = [...(blocks || []), ...fetchedItems];

// Configure grid layout
const gridConfig = parseGridConfig(numberOfColumns, gridClasses);
---

{gridConfig.usesGridTemplate && <style set:html={gridConfig.gridCSS} />}

<div class={sectionClasses}>
  {/* Results Summary - show for articles when there are filters or always if showResultsSummary is true */}
  {fetchItems === 'article' && (showResultsSummary || searchQuery || tagFilter) && (
    <ResultsSummary 
      totalResults={allBlocks.length}
      searchQuery={searchQuery}
      tagFilter={tagFilter}
    />
  )}

  <div
    id={gridConfig.usesGridTemplate ? gridConfig.gridId : undefined}
    class={gridConfig.usesGridTemplate ? `grid ${gridClasses}` : gridConfig.gridClassConfig}
    {...storyblokEditable(blok)}
  >
    {allBlocks?.map(nestedBlok => (
      <StoryblokComponent blok={nestedBlok} />
    ))}
  </div>
</div>
